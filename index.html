<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>101 æ”€çˆ¬è€… | æ‰‹æ„Ÿä¿®æ­£ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #020617; margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; touch-action: none; }
        #game-container { position: relative; width: 100%; max-width: 480px; height: 100vh; margin: 0 auto; background: #0f172a; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui" class="absolute top-0 left-0 w-full p-4 pointer-events-none z-10 hidden">
        <div class="bg-slate-900/80 backdrop-blur-sm border border-slate-700/50 rounded-xl p-4 shadow-xl">
            <div class="flex justify-between items-end mb-2">
                <div>
                    <div class="text-[10px] text-teal-500 font-bold tracking-widest uppercase">ç›®å‰é«˜åº¦</div>
                    <div class="text-3xl font-black text-white leading-none"><span id="floor-display">0</span><span class="text-sm text-slate-500 ml-1">/ 101F</span></div>
                </div>
                <div class="text-right">
                    <div class="text-[10px] text-teal-500 font-bold tracking-widest uppercase">ç¶“éæ™‚é–“</div>
                    <div id="timer-display" class="text-xl font-mono text-teal-300 leading-none">00:00:00</div>
                </div>
            </div>
            <div class="space-y-3 mt-2">
                <div>
                    <div class="flex justify-between text-[10px] font-bold mb-1">
                        <span class="text-sky-400">é«”åŠ› (STAMINA)</span>
                        <span id="stamina-val" class="text-slate-400">100 / 100</span>
                    </div>
                    <div class="w-full bg-slate-950 h-3 rounded-full overflow-hidden border border-slate-800">
                        <div id="stamina-bar" class="h-full bg-gradient-to-r from-sky-600 to-sky-400 transition-all duration-100" style="width: 100%"></div>
                    </div>
                </div>
                <div>
                    <div class="flex justify-between text-[10px] font-bold mb-1">
                        <span class="text-slate-400">æ­¢æ»‘ç²‰ (CHALK)</span>
                        <span id="chalk-val" class="text-slate-500">100%</span>
                    </div>
                    <div class="w-full bg-slate-950 h-1.5 rounded-full overflow-hidden border border-slate-800">
                        <div id="chalk-bar" class="h-full bg-slate-400 transition-all duration-100" style="width: 100%"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="overlay" class="absolute inset-0 z-20 flex flex-col items-center justify-center bg-slate-950/95 p-6 text-center">
        <div id="start-screen" class="space-y-8 animate-fade-in">
            <div class="text-8xl mb-4 animate-bounce">ğŸ§—</div>
            <div>
                <h1 class="text-5xl font-black italic text-transparent bg-clip-text bg-gradient-to-br from-teal-300 to-sky-600 mb-2">101 CLIMBERS</h1>
                <p class="text-slate-400 text-xs tracking-[0.2em] uppercase">æŒ‘æˆ°å°åŒ—å¤©éš›ç·š</p>
            </div>
            <div class="grid grid-cols-2 gap-3 text-left bg-slate-900/50 p-6 rounded-2xl border border-slate-800 text-sm text-slate-300">
                <div class="flex items-center gap-2"><span class="bg-slate-700 px-2 py-1 rounded text-xs font-bold text-white">Z</span> æŠ“æ¡ (Hold)</div>
                <div class="flex items-center gap-2"><span class="bg-slate-700 px-2 py-1 rounded text-xs font-bold text-white">X</span> è·³èº (Jump)</div>
                <div class="flex items-center gap-2 col-span-2"><span class="bg-slate-700 px-2 py-1 rounded text-xs font-bold text-white">SPACE</span> è“„åŠ› (Charge)</div>
                <div class="col-span-2 text-xs text-orange-400 mt-2 border-t border-slate-800 pt-2 text-center">è“„åŠ›è·³èºå°‡æ¶ˆè€—å¤§é‡é«”åŠ›ï¼</div>
            </div>
            <button onclick="Game.start()" class="w-full px-8 py-4 bg-teal-600 hover:bg-teal-500 text-white font-black text-xl rounded-xl transition-all shadow-[0_0_20px_rgba(20,184,166,0.3)]">é–‹å§‹æ”€ç™»</button>
        </div>

        <div id="end-screen" class="hidden space-y-6">
            <h2 id="end-title" class="text-4xl font-black text-white"></h2>
            <div class="bg-slate-900 p-6 rounded-xl border border-slate-800 space-y-2">
                <div class="text-slate-400 text-sm">æœ€çµ‚é«˜åº¦</div>
                <div class="text-3xl font-bold text-teal-400"><span id="end-floor">0</span> F</div>
                <div class="text-slate-400 text-sm mt-4">èŠ±è²»æ™‚é–“</div>
                <div id="end-time" class="text-xl font-mono text-white">00:00:00</div>
            </div>
            <button onclick="location.reload()" class="px-8 py-3 bg-slate-700 hover:bg-slate-600 text-white font-bold rounded-lg w-full">å†æ¬¡æŒ‘æˆ°</button>
        </div>
    </div>
</div>

<script>
const CONSTANTS = {
    COLORS: {
        SKY_TOP: '#020617', SKY_BOTTOM: '#0f172a',
        BUILDING: '#1e293b', GLASS: '#115e59', MULLION: '#334155',
        PLAYER: '#38bdf8', PLAYER_CHARGE: '#ffffff', PLAYER_MAX_CHARGE: '#ef4444',
        GRIP_NORMAL: '#fbbf24', GRIP_REST: '#22c55e',
        ITEM_BG: '#1e293b', BORDER_PINEAPPLE: '#fbbf24', BORDER_CHALK: '#94a3b8',
        WIND: 'rgba(255, 255, 255, 0.3)'
    },
    SETTINGS: {
        floorHeight: 400, buildingWidth: 400,
        gravity: 0.28, friction: 0.85, airResistance: 0.97,
        moveSpeed: 4.8, climbSpeed: 4.0, airControl: 0.22,
        jumpPower: 8.5, maxCharge: 60, chargeJumpCost: 15, // ä¿®æ­£ï¼šè“„åŠ›è·³æ¶ˆè€—
        staminaDrain: 0.15, staminaRecover: 0.5,
        chalkDrain: 0.12, chalkRefill: 40,
        maxChalk: 100, pineappleBonus: 45
    },
    KEYS: { UP: ['arrowup','w'], DOWN: ['arrowdown','s'], LEFT: ['arrowleft','a'], RIGHT: ['arrowright','d'], GRAB: ['z'], JUMP: ['x'], CHARGE: [' '] }
};

const Game = {
    canvas: null, ctx: null,
    state: {
        active: false, startTime: 0,
        cameraY: 0, floor: 0, celebrationTime: 0,
        player: { x: 0, y: 0, w: 24, h: 32, vx: 0, vy: 0, stamina: 100, maxStamina: 100, chalk: 100, isHolding: false, grabLock: false, charge: 0 },
        inputs: {}, prevInputs: {},
        objects: { grips: [], items: [], texts: [], particles: [], wind: [], fireworks: [], flag: null },
        wind: { force: 0, timer: 0 }
    },

    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('keydown', e => this.handleInput(e, true));
        window.addEventListener('keyup', e => this.handleInput(e, false));
    },

    resize() { this.canvas.width = 400; this.canvas.height = window.innerHeight; },
    handleInput(e, isDown) { const k = e.key.toLowerCase(); this.state.inputs[k] = isDown; if([' '].includes(k)) e.preventDefault(); },
    isPressed(action) { return CONSTANTS.KEYS[action].some(k => this.state.inputs[k]); },
    justPressed(action) { return CONSTANTS.KEYS[action].some(k => this.state.inputs[k] && !this.state.prevInputs[k]); },
    wasPressed(action) { return CONSTANTS.KEYS[action].some(k => !this.state.inputs[k] && this.state.prevInputs[k]); },

    start() {
        this.state.active = true;
        this.state.startTime = Date.now();
        this.state.player.x = 200 - 12; this.state.player.y = 80;
        this.generateLevel();
        document.getElementById('overlay').classList.add('hidden');
        document.getElementById('ui').classList.remove('hidden');
        requestAnimationFrame(t => this.loop(t));
    },

    generateLevel() {
        const { grips, items, texts } = this.state.objects;
        const { SETTINGS } = CONSTANTS;
        let curY = 0, lastX = 200, normalCount = 0;

        const addGrip = (x, y, w, h, type, extra = {}) => {
            if (grips.some(g => Math.abs(g.y - y) < 40)) return false;
            grips.push({ x, y, w, h, type, ...extra });
            lastX = x + w/2; return true;
        };

        const getNextX = (w, dev, y) => {
            const widthAtY = (y > 90 * SETTINGS.floorHeight) ? 280 : 400;
            const min = Math.max(200 - widthAtY/2 + 20, lastX - dev - w/2);
            const max = Math.min(200 + widthAtY/2 - w - 20, lastX + dev - w/2);
            return min + Math.random() * (max - min);
        };

        addGrip(0, 0, 400, 60, 'REST');
        texts.push({ x: 200, y: 150, text: "1F" });
        texts.push({ x: 200, y: 120, text: "æŒ‰ 'Z' æŠ“æ¡ / 'X' è·³èº / 'SPACE' è“„åŠ›", size: 14 });

        curY = 180;
        const spawnPineapples = (minF, maxF, count) => {
            for(let i=0; i<count; i++) {
                const fy = (minF + Math.random()*(maxF-minF)) * SETTINGS.floorHeight;
                items.push({ x: 0, y: fy, w: 44, h: 44, type: 'PINEAPPLE', active: true, pendingPlace: true });
            }
        };
        spawnPineapples(1, 30, 10); spawnPineapples(30, 60, 8); spawnPineapples(60, 90, 3);

        while (curY < 101 * SETTINGS.floorHeight) {
            const floor = Math.floor(curY / SETTINGS.floorHeight);
            let type = 'NORMAL';
            let w, h, jumpDist;
            let extra = {};

            // 1-5F: ç°¡å–®è·³èº (0.6-0.7å€)
            if (curY < 5 * SETTINGS.floorHeight) {
                type = 'REST'; w = 150 + Math.random() * 80; h = 24; jumpDist = 120;
            } 
            // 90F+: å·”å³°æ­»é¬¥ (ç§»å‹•, æ¥µå°, ç„¡REST)
            else if (floor >= 90) {
                type = 'NORMAL'; w = 25 + Math.random() * 15; h = 25 + Math.random() * 15; jumpDist = 200 + Math.random() * 50;
            }
            // 60F+: é–‹å§‹å‡ºç¾ç§»å‹•è‰²å¡Š
            else if (floor >= 60) {
                const restProb = 0.15; // é™ä½ç¶ è‰²æ©Ÿç‡
                if (Math.random() < restProb) { type = 'REST'; normalCount=0; } else { type = 'NORMAL'; normalCount++; }
                w = type === 'REST' ? 100 : 40 + Math.random()*30;
                h = type === 'REST' ? 24 : 140;
                jumpDist = type === 'REST' ? 150 : 180;
                // ç§»å‹•é‚è¼¯ (ç¯„åœä¸è¶…å‡ºç•«é¢)
                if (type === 'NORMAL' && Math.random() > 0.4) {
                    extra = { vx: 1.5 + Math.random(), range: 40 + Math.random()*60, startX: 0 };
                }
            }
            // 5-60F: ä¸€èˆ¬ç”Ÿæˆ
            else {
                if (normalCount >= 3) { type = 'REST'; normalCount = 0; } else { type = 'NORMAL'; normalCount++; }
                w = type === 'REST' ? 120 + Math.random()*60 : 40 + Math.random()*30;
                h = type === 'REST' ? 24 : 140;
                jumpDist = type === 'REST' ? 150 : 180;
            }

            // è¨ˆç®—åº§æ¨™ (è€ƒæ…®ç§»å‹•å¾Œçš„ç¯„åœ)
            let tryX = getNextX(w, 180, curY);
            if (extra.vx) {
                extra.startX = tryX; // è¨­å®šä¸­å¿ƒé»
                // ç¢ºä¿æ“ºå‹•ä¸è¶…å‡ºç‰†å£
                if (tryX - extra.range < 20) extra.startX = 20 + extra.range;
                if (tryX + extra.range + w > 380) extra.startX = 380 - w - extra.range;
            }

            if (addGrip(extra.startX || tryX, curY, w, h, type, extra)) {
                items.forEach(it => { if (it.pendingPlace && Math.abs(it.y - curY) < 200) { it.x = lastX - 22; it.y = curY + h + 20; it.pendingPlace = false; } });
                if (type === 'REST' && floor % 5 === 0) texts.push({ x: lastX, y: curY + 60, text: `${floor}F`, size: 14 });
                curY += jumpDist;
            } else curY += 50;
        }

        const finalY = 101 * SETTINGS.floorHeight;
        addGrip(100, finalY, 200, 40, 'REST');
        this.state.objects.flag = { x: 200, y: finalY + 40, w: 40, h: 60 };
        texts.push({ x: 200, y: finalY + 120, text: "VICTORY", size: 20 });
    },

    checkChalkRegen() {
        const { items } = this.state.objects;
        const { player, floor } = this.state;
        const nearby = items.filter(it => it.type === 'CHALK' && it.active && Math.abs(it.y - player.y) < 800).length;
        let max = floor < 30 ? 4 : (floor < 60 ? 3 : (floor < 90 ? 2 : 1));
        if (nearby < max && Math.random() < 0.02) {
             const spawnY = player.y + 300 + Math.random() * 300;
             items.push({ x: Math.random() * 300 + 50, y: spawnY, w: 44, h: 44, type: 'CHALK', active: true, floatOffset: 0 });
        }
    },

    physics(time) {
        const { player, objects, wind } = this.state;
        const { SETTINGS } = CONSTANTS;

        // ç§»å‹•è‰²å¡Šé‚è¼¯
        objects.grips.forEach(g => {
            if (g.vx) g.x = g.startX + Math.sin(time / 500 * g.vx) * g.range;
        });

        // å‹åˆ©
        if (objects.flag && player.x < objects.flag.x + objects.flag.w && player.x + player.w > objects.flag.x &&
            player.y < objects.flag.y + objects.flag.h && player.y + player.h > objects.flag.y) { this.victory(); return; }

        if (this.state.floor >= 90) {
            wind.timer++;
            if (wind.timer > 200) { wind.force = (Math.random()-0.5) * 2.0; wind.timer = 0; }
            player.vx += wind.force * 0.1;
        }

        this.checkChalkRegen();

        const standingOn = objects.grips.find(g => g.type === 'REST' && player.x + player.w > g.x && player.x < g.x + g.w && player.y <= g.y + g.h + 2 && player.y >= g.y + g.h - 10 && player.vy <= 0);
        const canGrab = objects.grips.find(g => player.x + player.w > g.x && player.x < g.x + g.w && player.y + player.h > g.y && player.y < g.y + g.h);

        const holdingInput = this.isPressed('GRAB');
        const jumpInput = this.justPressed('JUMP');
        const chargeInput = this.isPressed('CHARGE');
        const wasChargeInput = this.wasPressed('CHARGE');
        if (!holdingInput) player.grabLock = false;

        // --- CLIMBING ---
        if (holdingInput && canGrab && !player.grabLock && player.stamina > 0) {
            player.isHolding = true; player.vx = 0; player.vy = 0;
            player.stamina -= SETTINGS.staminaDrain;
            player.chalk = Math.max(0, player.chalk - SETTINGS.chalkDrain);
            if (player.chalk <= 0) player.stamina -= SETTINGS.staminaDrain;

            // ä¿®æ­£ï¼šé™åˆ¶åœ¨è‰²å¡Šç¯„åœå…§ (Clamping)
            const g = canGrab;
            if (this.isPressed('UP')) player.y += SETTINGS.climbSpeed;
            if (this.isPressed('DOWN')) player.y -= SETTINGS.climbSpeed;
            if (this.isPressed('LEFT')) player.x -= SETTINGS.climbSpeed;
            if (this.isPressed('RIGHT')) player.x += SETTINGS.climbSpeed;
            
            // Xè»¸é™åˆ¶ï¼šä¸çˆ¬å‡ºå·¦å³é‚Šç•Œ
            player.x = Math.max(g.x, Math.min(g.x + g.w - player.w, player.x));
            // Yè»¸é™åˆ¶ï¼šé ­éƒ¨ä¸è¶…éæ–¹å¡Šé ‚éƒ¨
            player.y = Math.min(g.y + g.h - player.h, player.y);

            // å¿«é€Ÿä¸Šç‰† (Green Block Climb Up)
            if (g.type === 'REST' && this.isPressed('UP') && player.y + player.h >= g.y + g.h - 10) {
                 player.isHolding = false; player.y = g.y + g.h;
            }

            if (chargeInput) player.charge = Math.min(SETTINGS.maxCharge, player.charge + 1.5);
            else if (wasChargeInput) this.executeJump();
            else if (jumpInput) this.executeJump();
        } 
        // --- STANDING ---
        else if (standingOn) {
            player.isHolding = false; player.vy = 0; player.y = standingOn.y + standingOn.h;
            // ä¿®æ­£ï¼šè·Ÿéš¨ç§»å‹•å¹³å°
            if (standingOn.vx) {
                 const prevX = standingOn.startX + Math.sin((time-16) / 500 * standingOn.vx) * standingOn.range;
                 player.x += (standingOn.x - prevX);
            }
            player.stamina = Math.min(player.maxStamina, player.stamina + SETTINGS.staminaRecover);
            player.vx *= SETTINGS.friction;
            if (this.isPressed('LEFT')) player.vx -= 1;
            if (this.isPressed('RIGHT')) player.vx += 1;
            
            if (chargeInput) { player.charge = Math.min(SETTINGS.maxCharge, player.charge + 1.5); player.vx = 0; }
            else if (wasChargeInput || jumpInput) this.executeJump();
        } 
        // --- AIR ---
        else {
            player.isHolding = false; player.vy -= SETTINGS.gravity; player.vx *= SETTINGS.airResistance;
            if (this.isPressed('LEFT')) player.vx -= SETTINGS.airControl;
            if (this.isPressed('RIGHT')) player.vx += SETTINGS.airControl;
        }

        player.x += player.vx; player.y += player.vy;
        if (player.x < 0) { player.x = 0; player.vx = 0; }
        if (player.x > 400 - player.w) { player.x = 400 - player.w; player.vx = 0; }

        objects.items.forEach(it => {
            if (!it.active || it.pendingPlace) return;
            if (player.x < it.x + it.w && player.x + player.w > it.x && player.y < it.y + it.h && player.y + player.h > it.y) {
                it.active = false;
                if (it.type === 'PINEAPPLE') { player.maxStamina += 10; player.stamina = Math.min(player.maxStamina, player.stamina + SETTINGS.pineappleBonus); }
                else { player.chalk = 100; }
            }
        });

        if (player.y < this.state.cameraY - 400) this.gameOver();
    },

    executeJump() {
        const { player } = this.state;
        const { SETTINGS } = CONSTANTS;
        const isChargeJump = player.charge > 5;
        // ä¿®æ­£ï¼šè“„åŠ›è·³æ¶ˆè€—
        if (isChargeJump) {
             player.stamina = Math.max(0, player.stamina - SETTINGS.chargeJumpCost);
        }
        const power = SETTINGS.jumpPower * (1 + (player.charge / SETTINGS.maxCharge) * 1.0);
        player.vy = power;
        if (this.isPressed('LEFT')) player.vx = -4.5;
        if (this.isPressed('RIGHT')) player.vx = 4.5;
        player.charge = 0; player.isHolding = false;
        if (this.isPressed('GRAB')) player.grabLock = true;
    },

    victory() {
        this.state.active = false;
        document.getElementById('end-screen').classList.remove('hidden');
        document.getElementById('end-title').innerText = "ç™»é ‚æˆåŠŸï¼";
        document.getElementById('end-title').classList.add('text-teal-400');
        this.updateEndStats();
        this.celebrationLoop();
    },
    gameOver() {
        this.state.active = false;
        document.getElementById('end-screen').classList.remove('hidden');
        document.getElementById('end-title').innerText = "æŒ‘æˆ°å¤±æ•—...";
        document.getElementById('end-title').classList.add('text-red-500');
        this.updateEndStats();
    },
    updateEndStats() {
        document.getElementById('end-floor').innerText = this.state.floor;
        document.getElementById('end-time').innerText = document.getElementById('timer-display').innerText;
        document.getElementById('ui').classList.add('hidden');
    },
    createFirework() {
        const x = Math.random() * 400; const y = this.state.cameraY + 200 + Math.random() * 400;
        const color = `hsl(${Math.random()*360}, 100%, 50%)`;
        for(let i=0; i<20; i++) {
            const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 5;
            this.state.objects.fireworks.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, color, life: 60 });
        }
    },
    celebrationLoop() {
        this.state.celebrationTime++;
        if (this.state.celebrationTime % 20 === 0) this.createFirework();
        const { fireworks } = this.state.objects;
        fireworks.forEach(f => { f.x += f.vx; f.y += f.vy; f.vy += 0.1; f.life--; });
        this.state.objects.fireworks = fireworks.filter(f => f.life > 0);
        this.render(); requestAnimationFrame(() => this.celebrationLoop());
    },

    loop(time) {
        if (!this.state.active) return;
        this.physics(time);
        const targetY = this.state.player.y - 300; this.state.cameraY += (targetY - this.state.cameraY) * 0.1;
        this.state.floor = Math.floor(this.state.player.y / CONSTANTS.SETTINGS.floorHeight);
        document.getElementById('floor-display').innerText = this.state.floor;
        document.getElementById('stamina-val').innerText = `${Math.floor(this.state.player.stamina)} / ${Math.floor(this.state.player.maxStamina)}`;
        document.getElementById('stamina-bar').style.width = (this.state.player.stamina / this.state.player.maxStamina * 100) + '%';
        document.getElementById('chalk-val').innerText = Math.floor(this.state.player.chalk) + '%';
        document.getElementById('chalk-bar').style.width = this.state.player.chalk + '%';
        const sBar = document.getElementById('stamina-bar');
        if (this.state.player.stamina < 30) sBar.className = "h-full bg-red-500 animate-pulse";
        else sBar.className = "h-full bg-gradient-to-r from-sky-600 to-sky-400";
        const diff = Date.now() - this.state.startTime;
        const ms = Math.floor((diff % 1000) / 10); const s = Math.floor((diff / 1000) % 60); const m = Math.floor(diff / 60000);
        document.getElementById('timer-display').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}:${ms.toString().padStart(2,'0')}`;
        this.render();
        this.state.prevInputs = { ...this.state.inputs };
        requestAnimationFrame(t => this.loop(t));
    },

    render() {
        const { ctx, canvas } = this;
        const { cameraY, player, objects, wind } = this.state;
        const { COLORS } = CONSTANTS;

        ctx.fillStyle = COLORS.SKY_BOTTOM; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.save(); ctx.translate(0, canvas.height); ctx.scale(1, -1); ctx.translate(0, -cameraY);

        ctx.strokeStyle = COLORS.MULLION; ctx.lineWidth = 1;
        const gridYStart = Math.floor(cameraY / 40) * 40;
        for (let y = gridYStart; y < cameraY + canvas.height; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(400, y); ctx.stroke(); }

        objects.texts.forEach(t => {
            if (t.y < cameraY - 100 || t.y > cameraY + canvas.height + 100) return;
            ctx.save(); ctx.translate(t.x, t.y); ctx.scale(1, -1);
            // ä¿®æ­£ï¼š14px ç™½è‰²å¯¦é«”å­—
            if (t.size) { ctx.fillStyle = "#fff"; ctx.font = "14px Arial"; ctx.fillText(t.text, 0, 0); }
            else { ctx.fillStyle = "rgba(255,255,255,0.15)"; ctx.font = "900 60px Arial"; ctx.textAlign = "center"; ctx.fillText(t.text, 0, 0); }
            ctx.restore();
        });

        objects.grips.forEach(g => {
            if (g.y < cameraY - 100 || g.y > cameraY + canvas.height + 100) return;
            ctx.fillStyle = g.type === 'REST' ? COLORS.GRIP_REST : COLORS.GRIP_NORMAL;
            // ä¿®æ­£ï¼š50F+ æ–œé‚Šæ•ˆæœ (Visual Skew)
            if (g.type === 'NORMAL' && Math.floor(g.y / 400) > 30) {
                 ctx.beginPath();
                 ctx.moveTo(g.x + 10, g.y); ctx.lineTo(g.x + g.w, g.y);
                 ctx.lineTo(g.x + g.w - 10, g.y + g.h); ctx.lineTo(g.x, g.y + g.h);
                 ctx.fill();
            } else {
                 ctx.fillRect(g.x, g.y, g.w, g.h);
            }
        });

        if (objects.flag) {
            const f = objects.flag;
            ctx.fillStyle = "#fff"; ctx.fillRect(f.x, f.y, 4, f.h);
            ctx.fillStyle = "#f43f5e"; ctx.beginPath(); ctx.moveTo(f.x+4, f.y+f.h); ctx.lineTo(f.x+40, f.y+f.h-15); ctx.lineTo(f.x+4, f.y+f.h-30); ctx.fill();
        }

        objects.items.forEach(it => {
            if (!it.active || it.pendingPlace) return;
            if (it.y < cameraY - 100 || it.y > cameraY + canvas.height + 100) return;
            it.floatOffset = (it.floatOffset || 0) + 0.1; const fy = Math.sin(it.floatOffset) * 5;
            ctx.fillStyle = COLORS.ITEM_BG; ctx.strokeStyle = it.type==='PINEAPPLE'?COLORS.BORDER_PINEAPPLE:COLORS.BORDER_CHALK;
            ctx.lineWidth = 2; ctx.beginPath(); ctx.roundRect(it.x, it.y + fy, it.w, it.h, 8); ctx.fill(); ctx.stroke();
            ctx.save(); ctx.translate(it.x + it.w/2, it.y + it.h/2 + fy); ctx.scale(1, -1);
            ctx.font = "24px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(it.type==='PINEAPPLE'?'ğŸ':'ğŸ¥¡', 0, 0); ctx.restore();
        });

        objects.fireworks.forEach(f => { ctx.fillStyle = f.color; ctx.fillRect(f.x, f.y, 4, 4); });

        if (Math.abs(wind.force) > 0.1) {
            ctx.strokeStyle = COLORS.WIND; ctx.lineWidth = 1;
            for(let i=0; i<5; i++) { const wx = Math.random()*400; const wy = cameraY + Math.random()*800; ctx.beginPath(); ctx.moveTo(wx, wy); ctx.lineTo(wx + wind.force*20, wy-5); ctx.stroke(); }
        }

        const squash = player.charge / CONSTANTS.SETTINGS.maxCharge;
        const dW = player.w * (1 + squash * 0.4), dH = player.h * (1 - squash * 0.4);
        const pX = player.x - (dW - player.w) / 2;

        if (player.isHolding) {
            ctx.save(); ctx.strokeStyle = "rgba(255, 255, 255, 0.8)"; ctx.lineWidth = 2; ctx.setLineDash([6, 4]); 
            ctx.strokeRect(pX - 6, player.y - 6, dW + 12, dH + 12); ctx.restore();
        }

        if (player.charge > 5) {
            ctx.strokeStyle = player.charge >= CONSTANTS.SETTINGS.maxCharge ? COLORS.PLAYER_MAX_CHARGE : '#fff';
            ctx.lineWidth = 2; ctx.strokeRect(pX - 2, player.y - 2, dW + 4, dH + 4);
        }

        ctx.fillStyle = COLORS.PLAYER; ctx.fillRect(pX, player.y, dW, dH);
        if (player.charge > 0) { ctx.fillStyle = "#fff"; ctx.fillRect(pX, player.y + dH + 8, dW * squash, 4); }
        ctx.restore();
    }
};

Game.init();
</script>
</body>
</html>
